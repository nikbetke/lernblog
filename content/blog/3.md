---
title: "[3] KundeVorne, Kunde Hinten"
date: 2022-09-19T07:43:45+00:00
draft: false
---

Es ging wieder ran an das Supermarkprojekt, als nächsten sollten wir eine einfache Warteschlange programmieren, in der sich maximal zwei Kunden anstellen konnten: KundeVorne und KundeHinten. Die Kunden besaßen nun die Methode anstellen, mit der sie eine Methode in der neuen Klasse Warteschlange aufrufen sich selber als Parameter weitergeben und schließlich in der Klasse als Instanzvariable KundeVorne gespeichert werden. Reiht sich nun ein weiterer  Kunde bei der selben Warteschlange ein, so wird überprüft ob KundeVorne Inhalt hat (dies trifft in dem Beispiel zu) und wird dann als KundeHinten gespeichert. Nun wird eine weitere Methode in der Klasse implementiert. Diese holt den ersten Kunden aus der Warteschlange. Er speicher also den KundenVorne der Warteschlange als aktuellenKunden in der eigenen Klasse. Auch rücken die Kunden in der Warteschlange nach diesem Prozess automatisch auf, d.h der neue KundeVorne wird der alte KundeHinten. KundeHinten wird frei. Nachdem Programmieren dieses Fundamenten war die Aufgabe theoretisch erledigt, jedoch wurde die Grafik also die Darstellung Objekte des Kundens und der Kasse gar nicht berücksichtigt. Das war die nächste Aufgabe. Ich habe also jeweils neue Methoden programmiert die die Grafik korrekt aktualisieren. Als dies erledigt war testete ich meine "Simulation" und als alles funktioniert hat gab ich die Aufgabe ab. Fertig!

```
public class Queue<ContentType> {
    
    /* --------- Anfang der privaten inneren Klasse -------------- */
    
    private class QueueNode {

        private ContentType content = null;
        private QueueNode nextNode = null;

        /**
         * Ein neues Objekt vom Typ QueueNode<ContentType> wird erschaffen. 
         * Der Inhalt wird per Parameter gesetzt. Der Verweis ist leer.
         * 
         * @param pContent das Inhaltselement des Knotens vom Typ ContentType
         */
        public QueueNode(ContentType pContent) {
            content = pContent;
            nextNode = null;
        }

        /**
         * Der Verweis wird auf das Objekt, das als Parameter uebergeben wird,
         * gesetzt.
         * 
         * @param pNext der Nachfolger des Knotens
         */
        public void setNext(QueueNode pNext) {
            nextNode = pNext;
        }
        
        /**
         * Liefert das naechste Element des aktuellen Knotens.
         * 
         * @return das Objekt vom Typ QueueNode, auf das der aktuelle Verweis zeigt
         */
        public QueueNode getNext() {
            return nextNode;
        }

        /**
         * Liefert das Inhaltsobjekt des Knotens vom Typ ContentType.
         * 
         * @return das Inhaltsobjekt des Knotens
         */
        public ContentType getContent() {
            return content;
        }
        
    }
    
    /* ----------- Ende der privaten inneren Klasse -------------- */
    
    private QueueNode head;
    private QueueNode tail;

    /**
     * Eine leere Schlange wird erzeugt. 
     * Objekte, die in dieser Schlange verwaltet werden, muessen vom Typ
     * ContentType sein.
     */
    public Queue() {
        head = null;
        tail = null;
    }

    /**
     * Die Anfrage liefert den Wert true, wenn die Schlange keine Objekte enthaelt, 
     * sonst liefert sie den Wert false.
     * 
     * @return true, falls die Schlange leer ist, sonst false
     */
    public boolean isEmpty() {
        return head == null;
    }

    /**
     * Das Objekt pContentType wird an die Schlange angehaengt. 
     * Falls pContentType gleich null ist, bleibt die Schlange unveraendert.
     * 
     * @param pContent
     *            das anzuhaengende Objekt vom Typ ContentType
     */
    public void enqueue(ContentType pContent) {
        if (pContent != null) {
            QueueNode newNode = new QueueNode(pContent);
            if (this.isEmpty()) {
                head = newNode;
                tail = newNode;
            } else {
                tail.setNext(newNode);
                tail = newNode;
            }
        }
    }

    /**
     * Das erste Objekt wird aus der Schlange entfernt. 
     * Falls die Schlange leer ist, wird sie nicht veraendert.
     */
    public void dequeue() {
        if (!this.isEmpty()) {
            head = head.getNext();
            if (this.isEmpty()) {
                head = null;
                tail = null;
            }
        }
    }

    /**
     * Die Anfrage liefert das erste Objekt der Schlange. 
     * Die Schlange bleibt unveraendert. 
     * Falls die Schlange leer ist, wird null zurueckgegeben.
     *
     * @return das erste Objekt der Schlange vom Typ ContentType oder null,
     *         falls die Schlange leer ist
     */
    public ContentType front() {
        if (this.isEmpty()) {
            return null;
        } else {
            return head.getContent();
        }
    }
}
``` 